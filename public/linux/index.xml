<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux相关 on Runto&#39;s Blog</title>
    <link>http://10.0.2.3/linux/</link>
    <description>Recent content in Linux相关 on Runto&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="http://10.0.2.3/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>设计思想</title>
      <link>http://10.0.2.3/linux/design-concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://10.0.2.3/linux/design-concept/</guid>
      <description>企业应用云操作系统 
对于企业IT来说，企业应用是企业IT价值的最主要体现，然而，当前不管是开发应用还是使用应用，都需要面对最底层的计算资源（IaaS/虚拟化/物理服务器），导致技术栈很长，需要做很多跟业务不直接相关的工作，比如：开发和运行环境搭建；服务器管理；网络管理；交付流程管理；技术架构支持；基础技术服务提供；技术工具维护等运维和技术工作，而这些工作对所有企业应用是有通用性的，如果把这些工作统一包装并自动化完成，企业专注自身业务，这样就能让企业IT的效率大幅度提高。
Rainbond 通过 以应用为中心 的方式包装以上重复性工作，并在此上支撑企业应用的开发、架构、交付和运维，这种抽象粒度，即能简化企业应用的管理，又能满足业务的灵活性。在对接底层基础设施时，通过软件定义实现和对接，能做到对接各类基础设施。通过以上设计，自然形成了企业应用的操作系统。
无侵入架构 
Rainbond把广泛支撑企业应用作为首要目标，广泛支撑企业应用意味着各种企业应用都能在Rainbond上开发、架构、运维，这点也是影响使用体验的关键点，为了实现这个目标，Rainbond采用无侵入架构。无侵入架构表现在使用简单，已有应用不需要改动就能支持。
具体从三方面入手：
 在开发阶段，对接代码仓库，自动识别开发语言类型，不改变开发者习惯，尽量最大可能不修改现有代码，直接编译、构建和运行。
 在架构阶段，如果已有系统没有分布式架构，Rainbond提供Service Mesh 架构，业务模块不改代码就能变成微服务架构。
 在运维阶段，老的遗留系统很难找到原有开发人员，要迁移到新运行环境比较困难，Rainbond使用动态生成配置文件和网络关系的方式，迁移和运行遗留系统。运维和治理功能，Rainbond通过“无侵入”插件的形式提供，根据功能需要选择加载插件。
  无侵入架构还表现在，对使用者无绑定，开发的应用程序可以脱离Rainbond开发和运行。
以应用为中心，连接企业应用和企业计算资源 
以应用为中心是Rainbond的核心设计理念，也是Rainbond的抽象思路，强调关注业务，跟业务相关技术概念对外暴露，跟业务不直接相关的技术概念统一包装。通过这种方式抽象，使用者不用过多考虑服务器的问题，也就是Serverless架构。
通过以应用为中心抽象可以将企业应用和企业计算资源解耦，企业应用的生命周期管理跟计算资源不直接相关，也就是说企业应用的开发可以在任何类型的计算资源上，开发好的企业应用可以直接安装运行在任何类型的计算资源上，还可以随时从一个资源迁移到另一个资源。
计算资源对使用者完全透明，根据使用场景差异对接计算资源，当计算资源对接的是公有资源，就是公有云，当计算资源对接的是私有资源，就是私有云，当计算资源同时对接公有资源和私有资源，就是混合云。
Rainbond通过解耦实现连接企业应用和企业计算资源，对接的各类企业应用积累形成企业应用市场，对接的各类企业计算资源积累形成企业计算资源市场，应用市场中的应用和资源市场中的资源可以自由组合使用。组合使用的过程，表现为SaaS和PaaS两种交互界面。SaaS实现不懂技术的即点即用，PaaS实现高级的定制开发。</description>
    </item>
    
    <item>
      <title>业务流程</title>
      <link>http://10.0.2.3/linux/flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://10.0.2.3/linux/flow/</guid>
      <description>抽象流程 
Rainbond的流程建立在以应用为中心抽象基础上，以交付为目的
场景流程 互联网公司交付流程 
企业软件公司交付流程 
行业云交付流程 
大型企事业单位IT流程</description>
    </item>
    
    <item>
      <title>Keepalived的使用方法</title>
      <link>http://10.0.2.3/linux/keepalived/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://10.0.2.3/linux/keepalived/</guid>
      <description>测试一下图片 抽象流程 
Rainbond的流程建立在以应用为中心抽象基础上，以交付为目的
场景流程 互联网公司交付流程 
企业软件公司交付流程 
行业云交付流程 
大型企事业单位IT流程</description>
    </item>
    
    <item>
      <title>技术架构</title>
      <link>http://10.0.2.3/linux/architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://10.0.2.3/linux/architecture/</guid>
      <description>Rainbond技术架构 
Rainbond践行以应用为中心的理念，吸纳优秀的社区解决方案，形成了应用控制、应用运行时，集群控制三大模块结合的数据中心逻辑技术架构，结合以管理节点、计算节点、网关节点、存储节点给类节点类型划分的物理架构形成高可用、高扩展性的数据中心架构体系。
在数据中心架构之上，根据使用目标人群划分为应用管理控制终端和资源管理控制终端，来分别服务于应用开发运维者和资源资源者。支撑用户同时管理和控制多个数据中心的多数据中心模式。
数据中心服务组件说明 数据中心API服务 API服务作为数据中心级抽象的核心控制服务，对外提供Restful风格的API服务，是数据中心控制请求的唯一入口，安全控制基于TLS双向安全认证。自主签发证书后分发到客户端。

API服务请求进入后由router模块进行请求分发，普通请求进入Handle请求处理模块，这类请求主要是操作数据库模型的请求，API服务基于ORM支持Mysql数据库和CockroachDB数据库。进入Proxy的请求分为API请求和Websocket请求。由Discover模块通过etcd服务发现其代理目标并转发请求。因此其他组件提供的API可通过服务注册由API服务代理转发请求。
应用网关服务 应用网关是外部流量进入Rainbond租户内部组件的唯一入口, 提供HTTP, HTTPs路由, TCP/UDP服务, 负载均衡器, 高级路由(A/B测试, 灰度发布)，虚拟IP支持等功能.
应用网关的设计灵感来自于NGINX Ingress Controller, 基于从kube-apiserver将监听到的Kubernetes资源(Ingress, Service, Secret, Endpoint)模型转化为Proxy控制器的配置，提供一种自动工作、实时生效、动态热配置的7层、4层网关服务。
应用网关可以通过水平扩展的方式来增加并发能力和基础性能，通用配置在所有网关节点中同步生效。对于74IP+
单节点应用网关服务的架构目标是支持多种数据源、支持多IP、支持高并发能力、支持多Server能力、支持动态配置变化能力。基于此需要应用网关架构设计如下：

应用网关服务集成Openresty服务作为前置流量代理服务，基于lua对Openresty实现功能扩展，Lua-Config-Controller实现对Openresty的动态配置、Upstream管理、负载均衡策略实现, Lua-Monitor-Controller实现对请求数据的记录和汇总上报、Lua-Security-Controller实现对请求的安全控制。三个Lua模块由Openresty-Controller驱动工作，Metric-Controller模块汇聚网关的各类监控数据并向外暴露Prometheus规范的Metric-Server。Openresty-Controller由数据驱动，数据来源于Gateway-Model-Controller，两层无耦合关系，其实现了标准的接口规范。根据需要我们可以实现基于其他proxy服务的驱动器，比如F5。
应用网关的数据模型来源支持kubernetes的ingress模型或从etcd中发现精简模型，由数据发现服务驱动整个网关动态工作。IP是网关的重要资源，IP-Port-Pool模块启动后将获取当前集群的所有可用IP地址和端口，并建立对IP地址变化的感知，IP-Manage模块将根据IP和端口数据判断网关策略是否在当前节点生效。
应用构建服务 Rainbond 应用构建服务处理CI过程，将输入源包括 源代码 或 Docker镜像 或 应用市场应用 进行解析、编译、打包，最终生成 应用（组件）的版本介质。
传统意义上说，完整的CI过程会包括：设计、编码、打包、测试和发布，Docker镜像自推出以来逐步成为众多应用代码打包的新形式。现有的CI产品中已经在源码测试和Pipline方面做得非常成熟，例如Jenkins，Gitlab等，因此Rainbond在对于源码或Docker镜像的前置处理方面可以直接对接第三方服务，由第三方服务处理完成的源码或镜像再对接到 Rainbond-Chaos 模块进行应用抽象。
Chaos的输入源是支持Git、Svn协议的代码仓库，Docker镜像仓库。如果是源代码，Chaos智能判断源码的类型，例如Java, PHP , Python, Dockerfile等，根据不同的源码类型选择对应的BuildingPack(源码构建器)进行源码编译，同时识别源码中定义的运行环境要求参数，应用端口、环境变量等参数，形成应用抽象的配置雏形。除了Dockerfile以外的源码类型将被编译成应用代码环境包（SLUG）存储于分布式存储中，其他的生成Docker本地镜像存储于数据中心镜像仓库中，结合应用的各类属性信息形成应用组件属性。
应用构建服务是无状态架构，由消息系统（rbd-mq）驱动的任务执行器设计。 实现了Git客户端和镜像仓库客户端，集成了SVN客户端来获取组件构建源资源。 任务执行过程记录完整日志由event客户端通过消息流将日志输入到rbd-event-log服务。每一个源码构建过程由Chaos控制调用本机Docker API创建构建容器并维护容器生命周期。
源码构建过程是一个非常消耗资源的过程，因此应用构建服务支持多节点部署来增加并发支持的构建任务数量，每一个节点支持的最大并发构建数量由节点CPU核数确定或运维人员手工设置。
  关于源码编译的BuildingPack参考各语言支持文档。 应用构建服务支持多点高可用部署，多点部署从消息中间件获取应用构建任务。   应用运行时控制服务 应用运行时控制服务将Rainbond-Application Model进行实例化转化为Kubernetes资源模型，配属应用运行需要的各类资源，完成应用生命周期中的运行态部分，可以理解为CD控制服务，该服务的设计要点是支撑大量应用的生命周期监管。
应用生命周期中可能经历启停、升级与回滚。不同的应用类型需要进行不同的控制策略，例如无状态应用能够进行无序的滚动升级，而有状态应用的升级控制策略将更加复杂。Worker服务中实现各类组件类型的生命周期控制器器、包含启动、停止、更新、伸缩等待。
应用运行需要各种外部环境支持，例如需要分配租户IP,端口等网络资源，需要根据应用设置配属持久化存储资源，例如共享文件存储分配存储目录，块存储等依托各类插件分配存储资源。 根据应用依赖属性建立服务发现和负载均衡策略供给mesh插件。根据应用属性生成调度策略调用Kubernetes集群调度应用运行。
目前Rainbond使用Kubernetes以下资源类型：Deployment、Statefulset、Service、Ingress、Secret、ConfigMap、Pod。对于用户来说，无需理解这些资源，产品中也不体现，其只是应用运行的载体。
Worker组件功能分为有状态部分和无状态部分，为了实现worker组件的集群部署，worker进行了主节点选举，选举为主节点的服务将提供应用存储Provider和存储统计服务。
Worker组件是kubernetes-controller控制器扩展和调度器扩展的模块，目前有实现本地存储Provider，有状态组件的共享存储Provider等等，其同时会获取Kubernetes集群中已有的资源供Rainbond应用组件选择使用。
Worker组件可支持多节点部署已保证高可用性。</description>
    </item>
    
  </channel>
</rss>